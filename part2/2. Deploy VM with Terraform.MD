[[_TOC_]]

# Setup

##Install the Azure CLI tools

In WSL:
```bash
curl -sL https://aka.ms/InstallAzureCLIDeb | sudo bash
```

##Login to Azure from the commandline

```bash
az login --tenant 1491bbb5-26ff-4146-a689-da9d7f9df86f
```

Follow the instructions to log into your BJSS Azure account in a browser

Official Install docs: https://docs.microsoft.com/en-us/cli/azure/install-azure-cli


## Install Terraform

* Install the Binaries

```bash
 wget -O- https://apt.releases.hashicorp.com/gpg | sudo gpg --dearmor -o /usr/share/keyrings/hashicorp-archive-keyring.gpg
 echo "deb [signed-by=/usr/share/keyrings/hashicorp-archive-keyring.gpg] https://apt.releases.hashicorp.com $(lsb_release -cs) main" | sudo tee /etc/apt/sources.list.d/hashicorp.list
 sudo apt update && sudo apt install terraform
```

* Verify the Install
```bash
terraform -version
```

Official Install Docs:
https://learn.hashicorp.com/tutorials/terraform/install-cli


# Running our Terraform

## Initalising Terraform

When we start working with our Terraform project we need to first initialise it. 
*"The terraform init command is used to initialize a working directory containing Terraform configuration files. This is the first command that should be run after writing a new Terraform configuration or cloning an existing one from version control. It is safe to run this command multiple times."*

In our WSL shell we first need to enter the directory which contains the sample terraform.

```bash
# Enter the sample directory (this may differ depending on where you have cloned your repository)

cd ~/code-to-cloud/day1/exercises/terraform-deployment
```

```bash
# Initialise our Terraform project
terraform init

# Example Output:
Initializing the backend...

Initializing provider plugins...
- Finding hashicorp/azurerm versions matching "~> 2.0"...
- Installing hashicorp/azurerm v2.49.0...
- Installed hashicorp/azurerm v2.49.0 (signed by HashiCorp)

Terraform has created a lock file .terraform.lock.hcl to record the provider
selections it made above. Include this file in your version control repository
so that Terraform can guarantee to make the same selections by default when
you run "terraform init" in the future.

Terraform has been successfully initialized!

You may now begin working with Terraform. Try running "terraform plan" to see
any changes that are required for your infrastructure. All Terraform commands
should now work.

If you ever set or change modules or backend configuration for Terraform,
rerun this command to reinitialize your working directory. If you forget, other
commands will detect it and remind you to do so if necessary.
```

## Running a Terraform Plan

The terraform plan command is used to create an execution plan. Terraform performs a refresh, and determines what actions it needs to take to achieve the desired state specified in the configuration files.
This command is a convenient way to check whether the execution plan for a set of changes matches your expectations without making any changes to real resources or to the state. For example, terraform plan might be run before committing a change to version control, to create confidence that it will behave as expected.

Running a Plan:

```bash
terraform plan

# You will be asked to input some details. Fill these in as appropriate.
# Put your academy team name
var.team_name
  Enter a value: zhang

# Use your surname or a nickname - unless someone else in your team has the same surname :)
var.user_id
  Enter a value: bennett
```

Study the output of the plan. It will show you the Resources that Terraform intends to update, create and destroy. It will also show the properties it intends to set. Notice that some properties are not available at plan stage, these will only be determined when the plan is executed.

NB. If you don't want to type the values each time you can specify these on the commandline as below. Or alternatively ask your Tutor how to permanently set these in the project.

```bash
terraform plan --var=team_name=<yourteamname> --var=user_id=<youruser>
```

## Executing Terrafom Apply

The terraform apply command is used to apply the changes required to reach the desired state of the configuration.

```bash 
# First we run the apply command (replace the values below with your team and user as before)
terraform apply --var=team_name=<yourteamname> --var=user_id=<youruser>

# Study the plan (if this was a real system we would ensure the plan looks correct and Isn't going to destroy important resources)
# Terraform will ask if you are sure you wish to apply the changes. Enter Yes to aceept and start the execution.
Do you want to perform these actions?
  Terraform will perform the actions described above.
  Only 'yes' will be accepted to approve.

  Enter a value: yes
  ```

If all goes well terraform will create the resources and output the Public Ip address for your newly created VM.

```bash
  Apply complete! Resources: 0 added, 0 changed, 0 destroyed.

Outputs:

azurerm_public_ip = "xx.xxx.xxx.xxx"
```

## Looking in the Portal

We can look at the resources created in the portal (look for the resource group that matches your team and name): https://portal.azure.com/?quickstart=True#blade/HubsExtension/BrowseResourceGroups

## Accessing your VM

We can access our VM using the public IP Address. In a browser navigate the IP address output by your terraform: http://<your IP Address>
You should see the Nginx Welcome Page.
<todo: Add IMage>

Another thing we can do is get remote shell access to the machine. To do this we use a utility (and protocol) called [SSH](https://en.wikipedia.org/wiki/SSH_(Secure_Shell))

```bash
# Create an SSH connection to VM (don't include the angle brackets! <>)
ssh azureuser@<your_ipaddress>

# Output:
Welcome to Ubuntu 18.04.5 LTS (GNU/Linux 5.4.0-1039-azure x86_64)
azureuser@bennettvm:
```
Now we are logged into the VM we can run various commands for example we can check the resource usage on the machine:

```bash
# Run the top command to see what is running
top
# To quit the top command, press q

# logout by typing exit:
exit

# Output:
logout
Connection to xxx.xxx.xxx.xxx closed.
```

## Making a Change In Terraform

Let make a change to our Terraform config and see what happens when we re-apply.

NB. The default editor in your linux is vi. If you have never used vi before ask your tutor to give you a quick 101 on how to edit and save. Alternatively you can open and edit files on your linux host in visual studio. If you prefer to do this you can type `code .` in your terminal.
See this page for further Details: https://code.visualstudio.com/docs/remote/wsl#_open-a-remote-folder-or-workspace \
For `vi` this is a useful guide: https://vim.fandom.com/wiki/Tutorial

```
# In main.tf find the resource called "myterraformgroup"

Amend the tags section to include a new tag (of your choosing)

Before:
resource "azurerm_resource_group" "myterraformgroup" {
  name     = "rg-academytf-${var.team_name}-${var.user_id}"
  location = "uksouth"

  tags = {
    project = "academy2021"
    team    = var.team_name
    user    = var.user_id
  }
}


After:
resource "azurerm_resource_group" "myterraformgroup" {
  name     = "rg-academytf-${var.team_name}-${var.user_id}"
  location = "uksouth"

  tags = {
    project = "academy2021"
    team    = var.team_name
    user    = var.user_id
    mynewtag   = "hello"
  }
}

# Save your changes
```

Now we have made a change to the tags on the resource group. Lets run our Plan again (if you set the default variables in the above step you will not need extra parameters). You should see that Terrafrom wants to do an in-place update and add the new Tag to the resource.
```bash
terraform plan --var=team_name=<yourteamname> --var=user_id=<youruser>


Example Output:
  # azurerm_resource_group.myterraformgroup will be updated in-place
  ~ resource "azurerm_resource_group" "myterraformgroup" {
        id       = "/subscriptions/993d9215-8911-4938-8121-9608c3ac1fd5/resourceGroups/rg-academytf-jamez-bennett"
        name     = "rg-academytf-jamez-bennett"
      ~ tags     = {
          + "mynewtag" = "mynewtagvalue"
            # (3 unchanged elements hidden)
        }
        # (1 unchanged attribute hidden)
    }

Plan: 0 to add, 1 to change, 0 to destroy.
```

NB. Sometimes Terrafrom can update a resource in-place. Some changes require it to destroy and recreate the resource. As you can imagine, this can be disruptive in a real environment. So care is always taken to review these plans carefully before applying.

If you are happy with your change let's apply it:
```bash
terraform apply --var=team_name=<yourteamname> --var=user_id=<youruser>

# If you are happy answer yes to make the change when prompted
```

You can check the new Tag appears in the portal by viewing your resource group.


## Destroying Our Infrastructure

The final command we are going to learn is `destroy` as the name suggests this will delete all the resources deployed by your Terraform config. This is useful when you are creating temporary infrastructure and want to clean up after yourself.
Lets clean up after ourselves:

```bash
terraform destroy --var=team_name=<yourteamname> --var=user_id=<youruser>

# Review the changes and confirm the prompt as before
```

Confirm your resources are gone in Azure.

